---
layout:     post                    # 使用的布局（不需要改）
title:      人工智能导论笔记【搜索】              # 标题 
subtitle:   一种求解问题的方式 #副标题
date:       2020-03-05          # 时间
author:     Alkane                      # 作者
header-img: img/ai.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 人工智能

---



# 搜索

## 写在前面的话

人工智能导论，讲的是一般性的方法、理论，不同于深度学习那样具体，但是会有很多有趣的东西，我很期待这门课给我带来的惊喜，老实说我不喜欢学校安排的单片机、软件工程这些课，一个是老师讲课不甚有趣，另一个就是我本人更喜欢理论一些的东西，有一种高屋建筑的感觉。

给自己的期望是一到两个星期写一篇这样的博客，整理记录自己的学习，也方便日后考研用。

## 背景知识介绍

### Agents

AI中的一个核心问题就是如何构造一个理想个体(rational agent),可以在面对所处的不同环境(enviroment)采取不同的动作(actions)来得到最佳的回馈.

我们在接下来的很多主题中都会借由agent的视角来看待问题。

### State Space & Search Problems

为了创造出一个理想的agent,我们需要从数学的角度来描述当前agent所处环境，这样才可以对agent后续的动作做出更好的选择。

下面是我们在搜索问题中会用到的一些定义

- s: 起始状态
- Action(s):状态s下允许的动作集合
- Cost(s,a):动作a的代价
- Succ(s,a):状态s执行动作a得到的状态(有可能是集合)
- IsGoal(s):状态s是否是目标状态

### State Space Graphs & Search Trees

一般的搜索问题都可以看成是在状态空间表示的图上进行搜索，下面我们来对什么是State Space Graphs做更深入的了解

我们知道,一个图是由节点(node)和边(edge)组成,不同的节点之间有边相连，有时候这些边还可能是带有权重的，也有可能是有向的，这要取决于不同的图的特性。

> A **state space graph** is constructed with states repre-senting nodes, with directed edges existing from a state to its successors.  These edges represent actions,and any associated weights represent the cost of performing the corresponding action

一个状态空间图(State Space Graph)是:

- 由不同的状态空间中的状态(state)组成其节点
- 节点之间的边表示动作(action),一条边由自身指向其后继(successor)
- 边上的权重表示这个动作的代价(cost)

通常来说，我们遇到的问题的状态空间是十分大的(比如围棋的状态空间)，一般无法直接画出来或是存储在计算机中，但是这并不影响我们很好的解决问题，得到最优解。

搜索树(Search Tree)是一个用于刻画搜索过程的树，具体的定义我们没必要给出，下面这张图就能说明搜索树是什么。

![](https://pic.downk.cc/item/5e60c55d98271cb2b89e2fd0.jpg)

我们这样再来看什么是搜索树:

- 根节点: 起始状态
- 叶节点: 目标状态
- 每条边表示一个动作
- 边上的权值表示代价
- 根节点到叶节点的路径表示一个解
- 最短路径表示最优解

## Uninformed Search

首先我们来了解一下没有信息的搜索(Uninformed Search)，也就是说，在进行搜索的过程中时，我们并不知道外界的相关信息(或者说不考虑除了节点本身以外的其他信息，如边的权值等)。

用统一的算法描述是这样的:

![](https://pic.downk.cc/item/5e60d43898271cb2b8a93c0c.jpg)

从算法的描述我们可以看出,这样的搜索只用到了状态空间表示图中的拓扑结构,也就是说只用到了这个状态与哪些状态相连了，而这个状态到其他状态需要付出的代价则不在我们的考虑之内(因为我们的搜索是uninformed search).

上面提到的搜索不像是算法，因为它实际上没法编程实现，更像是一类算法的概括，是方法论的一种。下面我们来看一下在这样的方法论指导下的几个具体的算法。

- 深度优先搜索(Deep First Search)
- 广度优先搜索(Breadth First Search)
- 统一代价搜索(Uniform Cost Search)

我们还会从以下几个角度来评价不同的搜索算法

- 完备性(completeness): 也就是这个算法是否能在有限时间内得到解
- 最优性(optimality):也就是得到的解是否是最优解
- 复杂度(complexity):包括时间复杂度与空间复杂度

### 深度优先搜索

> 深度优先搜索(DFS)是一种每次都选取深度最深的节点进行搜索的搜索策略

在深度优先搜索中，每次选取节点我们优先选取当前节点的子节点，若当前节点无子节点且当前节点不为目标节点，我们就回溯到上一层节点，从其子节点中选取一个未访问过的进行访问。

用图表示是:

![](https://pic.downk.cc/item/5e60f10498271cb2b8ba8222.jpg)

通常我们用栈这个数据结构来实现DFS.

简单的评价一下DFS:

- 不完备：你有可能找不到解，如果你的运气不够好，走了一条无底路的话:(
- 不最佳: 一般地，你会在最左边的最优解中退出，所以DFS很可能得不到最优解 :(
- 时间复杂度: 最差情况，DFS可能需要遍历所有节点，这可能需要耗费$O(b^m)$的时间
- 空间复杂度: 最差情况, DFS需要保留m层节点，也就是$O(bm)$的空间





### 广度优先搜索

> 广度优先搜索(BFS)是一种每次都选取深度最浅的节点以获取更大的广度的策略

在广度优先搜索中我们每次搜索都要先遍历当前节点所在层的所有节点，接着再遍历下一层。

用图表示是:

![](https://pic.downk.cc/item/5e60f38998271cb2b8bc3104.jpg)



而我们通常用队列来实现BFS.

评价:

- 完备性: 如果存在最优解,那么BFS一定可以得到最优解
- 最佳性:BFS得到的解一定是最优解
- 时间复杂度: $O(b^s)$，s为最优解所在的深度
- 空间复杂度:$O(b^s)$

### 迭代加深的深度优先搜索

广度优先搜索看起来比深度优先要好很多，但是在空间复杂度方面，广度优先搜索成为一个开销很大的算法，为了结合二者的优势，可以使用一个折衷的办法，迭代加深的DFS.

过程类似这样:

- DFS(深度=1)
- DFS(深度=2)
- DFS(深度=3)
- …

这样我们就可以用较小的空间复杂度来得到类似广度优先搜索的结果了。

### 等代价搜索

> 等代价搜索(UCS)是一种每次都选取距离开始节点距离最近的节点进行扩展的策略

在等代价搜索中，每次我们都选取目前为止从开始的点到当前点的代价最小的点。

![](https://pic.downk.cc/item/5e60fa8e98271cb2b8c017a0.jpg)

这里需要特别说明一下，之前的DFS,BFS我们其实都默认每一次动作的代价都是相同的，这样才能保证BFS得到的是最优解，而当不同的节点之间的代价不同时，BFS,DFS都不能得到最优解，而UCS可以，因为它保证了不会存在比当前路径更短的路径。

UCS通常用优先队列来实现

下面评价一下:

- 完备性:显然
- 最佳性:容易证明
- 时间复杂度:记最优路径的cost为$C^*$,俩个节点之间的最小cost为$\epsilon$,则时间复杂度为:$O(b^{C^*/\epsilon})$ 
- 空间复杂度:$O(b^{C^*/\epsilon})$

